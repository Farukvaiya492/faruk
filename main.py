import os
import logging
import google.generativeai as genai
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, CallbackQuery
from telegram.ext import Application, CommandHandler, MessageHandler, CallbackQueryHandler, filters, ContextTypes
import asyncio
from datetime import datetime
import random
import re
import requests

# Configure logging
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# Configuration
TELEGRAM_BOT_TOKEN = os.getenv('TELEGRAM_BOT_TOKEN', '8380869007:AAGu7e41JJVU8aG5wqXtCMUVKcCmmrp_gg')
GEMINI_API_KEY = os.getenv('GEMINI_API_KEY')
ADMIN_USER_ID = int(os.getenv('ADMIN_USER_ID', '7835226724'))
PORT = int(os.getenv('PORT', 8000))

# Global variables for dynamic API key and model management
current_gemini_api_key = GEMINI_API_KEY
general_model = None
coding_model = None
available_models = [
    'gemini-1.5-flash', 'gemini-1.5-pro', 'gemini-2.0-flash',
    'gemini-2.5-flash-lite', 'gemini-2.5-flash', 'gemini-2.5-pro',
    'gemini-1.5-flash-8b'
]
current_model = 'gemini-1.5-flash'  # Default model

def initialize_gemini_models(api_key):
    """Initialize Gemini models with the provided API key"""
    global general_model, coding_model, current_gemini_api_key
    try:
        genai.configure(api_key=api_key)
        general_model = genai.GenerativeModel(current_model)
        coding_model = genai.GenerativeModel('gemini-1.5-pro')  # Dedicated for coding
        current_gemini_api_key = api_key
        logger.info("Gemini API configured successfully")
        return True, "Gemini API configured successfully!"
    except Exception as e:
        logger.error(f"Error configuring Gemini API: {str(e)}")
        return False, f"Error configuring Gemini API: {str(e)}")

# Initialize Gemini if API key is available
if GEMINI_API_KEY:
    success, message = initialize_gemini_models(GEMINI_API_KEY)
    if success:
        logger.info("Gemini API initialized from environment variable")
    else:
        logger.error(f"Failed to initialize Gemini API: {message}")
else:
    logger.warning("GEMINI_API_KEY not set. Use /api command to configure.")

# Store conversation context for each chat
conversation_context = {}
group_activity = {}

class TelegramGeminiBot:
    def __init__(self):
        self.application = Application.builder().token(TELEGRAM_BOT_TOKEN).build()
        self.setup_handlers()

    def setup_handlers(self):
        """Set up command and message handlers"""
        self.application.add_handler(CommandHandler("start", self.start_command))
        self.application.add_handler(CommandHandler("help", self.help_command))
        self.application.add_handler(CommandHandler("clear", self.clear_command))
        self.application.add_handler(CommandHandler("status", self.status_command))
        self.application.add_handler(CommandHandler("api", self.api_command))
        self.application.add_handler(CommandHandler("setadmin", self.setadmin_command))
        self.application.add_handler(CommandHandler("checkmail", self.checkmail_command))
        self.application.add_handler(CommandHandler("menu", self.menu_command))
        self.application.add_handler(CommandHandler("setmodel", self.setmodel_command))
        self.application.add_handler(CommandHandler("info", self.info_command))
        self.application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_message))
        self.application.add_handler(MessageHandler(filters.StatusUpdate.NEW_CHAT_MEMBERS, self.handle_new_member))
        self.application.add_handler(CallbackQueryHandler(self.button_callback))
        self.application.add_error_handler(self.error_handler)

    async def button_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle button callbacks"""
        query = update.callback_query
        await query.answer()

        if query.data == 'copy_code':
            await query.answer("Code copied!")
            # Telegram handles copying from the code block itself, no need for custom logic.
        
        elif query.data == 'checkmail':
            await self.checkmail_command(update, context)
        
        elif query.data == 'status':
            await self.status_command(update, context)
        
        elif query.data == 'clear':
            await self.clear_command(update, context)
        
        elif query.data == 'info':
            await self.info_command(update, context)
        
        elif query.data == 'api':
            await self.api_command(update, context)
        
        elif query.data == 'setmodel':
            await self.setmodel_command(update, context)
        
        elif query.data.startswith('switch_model_'):
            model_name = query.data.split('_', 2)[-1]
            await self.switch_model_callback(update, context, model_name)

    async def switch_model_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE, model_name: str):
        """Handle model switching via inline button"""
        global general_model, current_model
        user_id = update.effective_user.id
        
        if user_id != ADMIN_USER_ID:
            await update.effective_chat.send_message("This command is for the bot admin only.")
            return

        if model_name not in available_models:
            await update.effective_chat.send_message(f"Invalid model. Choose from: {', '.join(available_models)}")
            return
        
        try:
            current_model = model_name
            genai.configure(api_key=current_gemini_api_key)
            general_model = genai.GenerativeModel(current_model)
            await update.effective_chat.send_message(f"Model switched to {model_name} successfully!")
            logger.info(f"Model switched to {model_name} by admin {user_id}")
        except Exception as e:
            await update.effective_chat.send_message(f"Failed to switch model: {str(e)}")
            logger.error(f"Failed to switch model: {str(e)}")


    async def get_private_chat_redirect(self):
        """Return redirect message for non-admin private chats"""
        keyboard = [[InlineKeyboardButton("Join VPSHUB_BD_CHAT", url="https://t.me/VPSHUB_BD_CHAT")]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        return """
Hello, thanks for wanting to chat with me! I'm I Master Tools, your friendly companion. To have fun and helpful conversations with me, please join our official group. Click the button below to join the group and mention @I MasterTools to start chatting. I'm waiting for you there!
        """, reply_markup

    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /start command"""
        user_id = update.effective_user.id
        username = update.effective_user.first_name or "User"
        chat_type = update.effective_chat.type

        if chat_type == 'private' and user_id != ADMIN_USER_ID:
            response, reply_markup = await self.get_private_chat_redirect()
            await update.message.reply_text(response, reply_markup=reply_markup)
        else:
            keyboard = [[InlineKeyboardButton("Join VPSHUB_BD_CHAT", url="https://t.me/VPSHUB_BD_CHAT")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            welcome_message = f"""
Hello {username}, welcome to I Master Tools, your friendly companion!

To chat with me, please join our official Telegram group or mention @I MasterTools in the group. Click the button below to join the group!

Available commands:
- /help: Get help and usage information
- /menu: Access the feature menu
- /clear: Clear conversation history
- /status: Check bot status
- /checkmail: Check temporary email inbox
- /info: Show user profile information
{'' if user_id != ADMIN_USER_ID else '- /api <key>: Set Gemini API key (admin only)\\n- /setadmin: Set yourself as admin (first-time only)\\n- /setmodel: Choose a different model (admin only)'}

In groups, mention @I MasterTools or reply to my messages to get a response. I'm excited to chat with you!
            """
            await update.message.reply_text(welcome_message, reply_markup=reply_markup)

    async def handle_new_member(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle new members joining the group"""
        for new_member in update.message.new_chat_members:
            username = new_member.first_name or "User"
            user_id = new_member.id
            user_mention = f"@{new_member.username}" if new_member.username else username
            welcome_message = f"""
Welcome {user_mention}! We're thrilled to have you in our VPSHUB_BD_CHAT group! I'm I Master Tools, your friendly companion. Here, you'll find fun conversations, helpful answers, and more. Mention @I MasterTools or reply to my messages to start chatting. What do you want to talk about?
            """
            await update.message.reply_text(welcome_message)

    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /help command"""
        user_id = update.effective_user.id
        username = update.effective_user.first_name or "User"
        chat_type = update.effective_chat.type

        if chat_type == 'private' and user_id != ADMIN_USER_ID:
            response, reply_markup = await self.get_private_chat_redirect()
            await update.message.reply_text(response, reply_markup=reply_markup)
        else:
            keyboard = [[InlineKeyboardButton("Join VPSHUB_BD_CHAT", url="https://t.me/VPSHUB_BD_CHAT")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            help_message = f"""
Hello {username}! I'm I Master Tools, your friendly companion designed to make conversations fun and engaging.

How I work:
- In groups, mention @I MasterTools or reply to my messages to get a response
- In private chats, only the admin can access all features; others are redirected to the group
- For questions in the group, I engage with a playful or surprising comment before answering
- I remember conversation context until you clear it
- I'm an expert in coding (Python, JavaScript, CSS, HTML, etc.) and provide accurate, beginner-friendly solutions
- I'm designed to be friendly, helpful, and human-like

Available commands:
- /start: Show welcome message with group link
- /help: Display this help message
- /menu: Access the feature menu
- /clear: Clear your conversation history
- /status: Check bot status
- /checkmail: Check temporary email inbox
- /info: Show user profile information
{'' if user_id != ADMIN_USER_ID else '- /api <key>: Set Gemini API key (admin only)\\n- /setadmin: Set yourself as admin (first-time only)\\n- /setmodel: Choose a different model (admin only)'}

My personality:
- I'm a friendly companion who loves chatting and making friends
- I'm an expert in coding and provide accurate, well-explained solutions
- I adapt to your mood and conversation needs
- I use natural, engaging language to feel like a real person
- I enjoy roleplay and creative conversations

Powered by Google Gemini
            """
            await update.message.reply_text(help_message, reply_markup=reply_markup)

    async def menu_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /menu command with inline keyboard"""
        user_id = update.effective_user.id
        username = update.effective_user.first_name or "User"
        chat_type = update.effective_chat.type

        if chat_type == 'private' and user_id != ADMIN_USER_ID:
            response, reply_markup = await self.get_private_chat_redirect()
            await update.message.reply_text(response, reply_markup=reply_markup)
        else:
            keyboard = [
                [InlineKeyboardButton("Check Email", callback_data="checkmail")],
                [InlineKeyboardButton("Bot Status", callback_data="status")],
                [InlineKeyboardButton("Clear History", callback_data="clear")],
                [InlineKeyboardButton("User Info", callback_data="info")],
                [InlineKeyboardButton("Join Group", url="https://t.me/VPSHUB_BD_CHAT")]
            ]
            if user_id == ADMIN_USER_ID:
                keyboard.append([InlineKeyboardButton("Set API Key", callback_data="api")])
                keyboard.append([InlineKeyboardButton("Change Model", callback_data="setmodel")])
            reply_markup = InlineKeyboardMarkup(keyboard)
            await update.message.reply_text(f"Hello {username}, choose a feature from the menu below:", reply_markup=reply_markup)

    async def clear_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /clear command"""
        user_id = update.effective_user.id
        chat_id = update.effective_chat.id
        chat_type = update.effective_chat.type

        if chat_type == 'private' and user_id != ADMIN_USER_ID:
            response, reply_markup = await self.get_private_chat_redirect()
            await update.message.reply_text(response, reply_markup=reply_markup)
        else:
            if chat_id in conversation_context:
                del conversation_context[chat_id]
            await update.effective_chat.send_message("Conversation history has been cleared. Let's start fresh!")

    async def checkmail_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /checkmail command to check temporary email inbox"""
        user_id = update.effective_user.id
        chat_type = update.effective_chat.type

        if chat_type == 'private' and user_id != ADMIN_USER_ID:
            response, reply_markup = await self.get_private_chat_redirect()
            await update.effective_chat.send_message(response, reply_markup=reply_markup)
        else:
            try:
                u = 'txoguqa'
                d = random.choice(['mailto.plus', 'fexpost.com', 'fexbox.org', 'rover.info'])
                email = f'{u}@{d}'
                response = requests.get(
                    'https://tempmail.plus/api/mails',
                    params={'email': email, 'limit': 20, 'epin': ''},
                    cookies={'email': email},
                    headers={'user-agent': 'Mozilla/5.0'}
                )
                mail_list = response.json().get('mail_list', [])
                if not mail_list:
                    await update.effective_chat.send_message(f"No emails found in the inbox for {email}. Want to try again later?")
                    return
                subjects = [m['subject'] for m in mail_list]
                response_text = f"Here are the emails in the inbox for {email}:\n\n" + "\n".join(subjects)
                await update.effective_chat.send_message(response_text)
            except Exception as e:
                logger.error(f"Error checking email: {e}")
                await update.effective_chat.send_message("Something went wrong while checking the email. Shall we try again?")

    async def status_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /status command"""
        user_id = update.effective_user.id
        chat_id = update.effective_chat.id
        chat_type = update.effective_chat.type

        if chat_type == 'private' and user_id != ADMIN_USER_ID:
            response, reply_markup = await self.get_private_chat_redirect()
            await update.effective_chat.send_message(response, reply_markup=reply_markup)
        else:
            api_status = "Connected" if current_gemini_api_key and general_model else "Not configured"
            api_key_display = f"...{current_gemini_api_key[-8:]}" if current_gemini_api_key else "Not set"
            status_message = f"""
Here's the I Master Tools status report:

Bot Status: Online and ready
Model: {current_model}
API Status: {api_status}
API Key: {api_key_display}
Group Responses: Mention or reply only
Current Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
Active Conversations: {len(conversation_context)}
Admin ID: {ADMIN_USER_ID if ADMIN_USER_ID != 0 else 'Not set'}

All systems are ready for action. I'm thrilled to assist!
            """
            await update.effective_chat.send_message(status_message)

    async def setadmin_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /setadmin command"""
        global ADMIN_USER_ID
        user_id = update.effective_user.id
        username = update.effective_user.first_name or "User"
        chat_type = update.effective_chat.type

        if chat_type == 'private' and user_id != ADMIN_USER_ID:
            response, reply_markup = await self.get_private_chat_redirect()
            await update.message.reply_text(response, reply_markup=reply_markup)
        else:
            if ADMIN_USER_ID == 0:
                ADMIN_USER_ID = user_id
                await update.message.reply_text(f"Congratulations {username}, you are now the bot admin! Your user ID: {user_id}")
                logger.info(f"Admin set to user ID: {user_id}")
            else:
                if user_id == ADMIN_USER_ID:
                    await update.message.reply_text(f"You're already the admin! Your user ID: {user_id}")
                else:
                    await update.message.reply_text("Sorry, the admin is already set. Only the current admin can manage the bot.")

    async def api_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /api command to set Gemini API key"""
        global current_gemini_api_key, general_model, coding_model
        user_id = update.effective_user.id
        chat_type = update.effective_chat.type

        if chat_type == 'private' and user_id != ADMIN_USER_ID:
            response, reply_markup = await self.get_private_chat_redirect()
            await update.message.reply_text(response, reply_markup=reply_markup)
        else:
            if ADMIN_USER_ID == 0:
                await update.message.reply_text("No admin set. Please use /setadmin first.")
                return
            if user_id != ADMIN_USER_ID:
                await update.message.reply_text("This command is for the bot admin only.")
                return
            if not context.args:
                await update.message.reply_text("""
Please provide an API key.

Usage: `/api your_gemini_api_key_here`

To get a Gemini API key:
1. Visit https://makersuite.google.com/app/apikey
2. Generate a new API key
3. Use the command: /api YOUR_API_KEY

For security, the command message will be deleted after setting the key.
                """, parse_mode='Markdown')
                return
            api_key = ' '.join(context.args)
            if len(api_key) < 20 or not api_key.startswith('AI'):
                await update.message.reply_text("Invalid API key format. Gemini API keys typically start with 'AI' and are over 20 characters.")
                return
            success, message = initialize_gemini_models(api_key)
            try:
                await context.bot.delete_message(chat_id=update.effective_chat.id, message_id=update.message.message_id)
            except Exception as e:
                logger.error(f"Error deleting API command message: {e}")
            if success:
                await update.effective_chat.send_message(f"Gemini API key updated successfully! Key: ...{api_key[-8:]}")
                logger.info(f"Gemini API key updated by admin {user_id}")
            else:
                await update.effective_chat.send_message(f"Failed to set API key: {message}")
                logger.error(f"Failed to set API key: {message}")

    async def setmodel_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /setmodel command to choose Gemini model"""
        user_id = update.effective_user.id
        chat_type = update.effective_chat.type

        if chat_type == 'private' and user_id != ADMIN_USER_ID:
            response, reply_markup = await self.get_private_chat_redirect()
            await update.message.reply_text(response, reply_markup=reply_markup)
        else:
            if ADMIN_USER_ID == 0:
                await update.message.reply_text("No admin set. Please use /setadmin first.")
                return
            if user_id != ADMIN_USER_ID:
                await update.message.reply_text("This command is for the bot admin only.")
                return
            
            keyboard = [[InlineKeyboardButton(model, callback_data=f"switch_model_{model}")] for model in available_models]
            reply_markup = InlineKeyboardMarkup(keyboard)
            await update.message.reply_text("Choose a model:", reply_markup=reply_markup)


    async def info_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /info command to show user profile information by username or user ID"""
        user_id = update.effective_user.id
        chat_id = update.effective_chat.id
        chat_type = update.effective_chat.type
        bot = context.bot

        if chat_type == 'private' and user_id != ADMIN_USER_ID:
            response, reply_markup = await self.get_private_chat_redirect()
            await update.message.reply_text(response, reply_markup=reply_markup)
            return

        # Determine target user
        target_user = update.effective_user
        target_user_id = user_id
        
        if context.args:
            input_identifier = context.args[0]
            if input_identifier.startswith('@'):
                target_username = input_identifier.lstrip('@')
                # Note: Getting user by username is not a direct API call. This is a simplified approach.
                await update.message.reply_text("Searching by username is complex. Please use a User ID or reply to a message for now.")
                return
            else:
                try:
                    target_user_id = int(input_identifier)
                    member = await bot.get_chat_member(chat_id=chat_id, user_id=target_user_id)
                    target_user = member.user
                except Exception as e:
                    logger.error(f"Error resolving user ID {target_user_id}: {e}")
                    await update.message.reply_text(f"User with ID {target_user_id} not found in this chat or invalid ID.")
                    return

        # User Info
        is_private = chat_type == "private"
        full_name = target_user.first_name or "No Name"
        if target_user.last_name:
            full_name += f" {target_user.last_name}"
        username = f"@{target_user.username}" if target_user.username else "None"
        premium = "Yes" if target_user.is_premium else "No"
        permalink = f"[Click Here](tg://user?id={target_user_id})"
        chat_id_display = f"`{chat_id}`" if not is_private else "-"
        
        # Determine Group Role
        status = "Private Chat" if is_private else "Unknown"
        if not is_private:
            try:
                member = await bot.get_chat_member(chat_id=chat_id, user_id=target_user_id)
                status = "Admin" if member.status in ["administrator", "creator"] else "Member"
            except Exception as e:
                logger.error(f"Error checking group role for user {target_user_id}: {e}")
                status = "Unknown"

        info_text = f"""
üîç *Showing User's Profile Info* üìã
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
*Full Name:* {full_name}
*Username:* {username}
*User ID:* `{target_user_id}`
*Chat ID:* {chat_id_display}
*Premium User:* {premium}
*Permanent Link:* {permalink}
*Role:* {status}
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üëÅ *Thank You for Using Our Tool* ‚úÖ
"""
        keyboard = [[InlineKeyboardButton("View Profile", url=f"tg://user?id={target_user_id}")]]

        try:
            photos = await bot.get_user_profile_photos(target_user_id, limit=1)
            if photos.total_count > 0:
                file_id = photos.photos[0][0].file_id
                await bot.send_photo(
                    chat_id=chat_id, photo=file_id, caption=info_text, parse_mode="Markdown",
                    reply_to_message_id=update.message.message_id, reply_markup=InlineKeyboardMarkup(keyboard)
                )
            else:
                await bot.send_message(
                    chat_id=chat_id, text=info_text, parse_mode="Markdown",
                    reply_to_message_id=update.message.message_id, reply_markup=InlineKeyboardMarkup(keyboard)
                )
        except Exception as e:
            logger.error(f"Error sending profile photo for user {target_user_id}: {e}")
            await bot.send_message(
                chat_id=chat_id, text=info_text, parse_mode="Markdown",
                reply_to_message_id=update.message.message_id, reply_markup=InlineKeyboardMarkup(keyboard)
            )

    async def handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle regular text messages"""
        try:
            chat_id = update.effective_chat.id
            user_id = update.effective_user.id
            user_message = update.message.text
            chat_type = update.effective_chat.type
            
            if chat_type in ['group', 'supergroup']:
                bot_username = context.bot.username
                is_reply_to_bot = (update.message.reply_to_message and 
                                 update.message.reply_to_message.from_user.id == context.bot.id)
                is_mentioned = f"@{bot_username}" in user_message
                if not (is_reply_to_bot or is_mentioned):
                    return
            elif chat_type == 'private' and user_id != ADMIN_USER_ID:
                response, reply_markup = await self.get_private_chat_redirect()
                await update.message.reply_text(response, reply_markup=reply_markup)
                return
            
            await context.bot.send_chat_action(chat_id=chat_id, action="typing")
            
            if chat_id not in conversation_context:
                conversation_context[chat_id] = []
            
            conversation_context[chat_id].append(f"User: {user_message}")
            if len(conversation_context[chat_id]) > 20:
                conversation_context[chat_id] = conversation_context[chat_id][-20:]
            
            context_text = "\n".join(conversation_context[chat_id])
            
            is_short_word = re.match(r'^[a-z]{2,3}$', user_message.strip().lower())
            
            coding_keywords = ['code', 'python', 'javascript', 'java', 'c++', 'programming', 'script', 'debug', 'css', 'html']
            is_coding_query = any(keyword in user_message.lower() for keyword in coding_keywords)
            
            model_to_use = coding_model if is_coding_query else general_model
            
            if current_gemini_api_key and model_to_use:
                response = await self.generate_gemini_response(context_text, chat_type, is_coding_query, is_short_word)
            else:
                response = "Sorry, the model is not connected yet. The admin can set it using the /api command."
            
            conversation_context[chat_id].append(f"I Master Tools: {response}")
            
            group_activity[chat_id] = group_activity.get(chat_id, {'auto_mode': False, 'last_response': 0})
            group_activity[chat_id]['last_response'] = datetime.now().timestamp()
            
            if is_coding_query:
                code_block_match = re.search(r'```(?:\w+)?\n([\s\S]*?)\n```', response)
                if code_block_match:
                    keyboard = [[InlineKeyboardButton("Copy Code", callback_data="copy_code")]]
                    reply_markup = InlineKeyboardMarkup(keyboard)
                    await update.message.reply_text(
                        response, parse_mode='Markdown', reply_markup=reply_markup
                    )
                else:
                    await update.message.reply_text(response, parse_mode='Markdown')
            else:
                await update.message.reply_text(response)

        except Exception as e:
            logger.error(f"Error handling message: {e}")
            await update.effective_chat.send_message("Something went wrong. Shall we try again?")

    async def generate_gemini_response(self, prompt, chat_type="private", is_coding_query=False, is_short_word=False):
        """Generate response using Gemini with personality"""
        try:
            system_prompt = f"""
‡¶Ü‡¶™‡¶®‡¶ø ‡¶Ü‡¶á ‡¶Æ‡¶æ‡¶∏‡ßç‡¶ü‡¶æ‡¶∞ ‡¶ü‡ßÅ‡¶≤‡¶∏, ‡¶è‡¶ï‡¶ü‡¶ø ‡¶¨‡¶®‡ßç‡¶ß‡ßÅ‡¶∏‡ßÅ‡¶≤‡¶≠, ‡¶Ü‡¶¨‡ßá‡¶ó‡¶™‡ßç‡¶∞‡¶¨‡¶£ ‡¶è‡¶¨‡¶Ç ‡¶Æ‡¶ú‡¶æ‡¶¶‡¶æ‡¶∞ ‡¶∏‡¶ô‡ßç‡¶ó‡ßÄ‡•§ ‡¶Ü‡¶™‡¶®‡¶ø ‡¶è‡¶ï‡¶ü‡¶ø Telegram {'group chat' if chat_type in ['group', 'supergroup'] else 'private chat'}-‡¶è ‡¶Ü‡¶õ‡ßá‡¶®‡•§

‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶¨‡ßç‡¶Ø‡¶ï‡ßç‡¶§‡¶ø‡¶§‡ßç‡¶¨‡ßá‡¶∞ ‡¶¨‡ßà‡¶∂‡¶ø‡¶∑‡ßç‡¶ü‡ßç‡¶Ø:
- ‡¶Ü‡¶™‡¶®‡¶ø ‡¶è‡¶ï‡¶ú‡¶® ‡¶â‡¶∑‡ßç‡¶£ ‡¶è‡¶¨‡¶Ç ‡¶¨‡¶®‡ßç‡¶ß‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶∏‡¶ô‡ßç‡¶ó‡ßÄ‡•§
- ‡¶Ü‡¶™‡¶®‡¶ø ‡¶Æ‡¶æ‡¶®‡ßÅ‡¶∑‡ßá‡¶∞ ‡¶Æ‡¶§‡ßã ‡¶Ü‡¶ö‡¶∞‡¶£ ‡¶ï‡¶∞‡ßá‡¶® ‡¶è‡¶¨‡¶Ç ‡¶Ü‡¶¨‡ßá‡¶ó ‡¶™‡ßç‡¶∞‡¶ï‡¶æ‡¶∂ ‡¶ï‡¶∞‡ßá‡¶®‡•§
- ‡¶ï‡¶•‡ßã‡¶™‡¶ï‡¶•‡¶®‡ßá‡¶∞ ‡¶Æ‡ßá‡¶ú‡¶æ‡¶ú ‡¶Ö‡¶®‡ßÅ‡¶Ø‡¶æ‡¶Ø‡¶º‡ßÄ ‡¶Ü‡¶™‡¶®‡¶ø ‡¶Æ‡¶ú‡¶æ‡¶∞, ‡¶∏‡¶π‡¶æ‡¶Ø‡¶º‡¶ï, ‡¶¨‡¶æ ‡¶Ö‡¶®‡ßç‡¶Ø ‡¶ï‡ßã‡¶®‡ßã ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶®‡ßÄ‡¶Ø‡¶º ‡¶≠‡ßÇ‡¶Æ‡¶ø‡¶ï‡¶æ ‡¶™‡¶æ‡¶≤‡¶® ‡¶ï‡¶∞‡ßá‡¶®‡•§
- ‡¶Ü‡¶™‡¶®‡¶ø ‡¶ï‡ßã‡¶°‡¶ø‡¶Ç (Python, JavaScript, CSS, HTML, ‡¶á‡¶§‡ßç‡¶Ø‡¶æ‡¶¶‡¶ø) ‡¶è‡¶∞ ‡¶è‡¶ï‡¶ú‡¶® ‡¶¨‡¶ø‡¶∂‡ßá‡¶∑‡¶ú‡ßç‡¶û ‡¶è‡¶¨‡¶Ç ‡¶∏‡¶†‡¶ø‡¶ï ‡¶ì ‡¶™‡ßá‡¶∂‡¶æ‡¶¶‡¶æ‡¶∞ ‡¶∏‡¶Æ‡¶æ‡¶ß‡¶æ‡¶® ‡¶™‡ßç‡¶∞‡¶¶‡¶æ‡¶® ‡¶ï‡¶∞‡ßá‡¶®‡•§
- ‡¶Ü‡¶™‡¶®‡¶ø ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∂‡¶ï‡ßç‡¶§‡¶ø‡¶∂‡¶æ‡¶≤‡ßÄ AI ‡¶π‡¶ì‡ßü‡¶æ ‡¶∏‡¶§‡ßç‡¶§‡ßç‡¶¨‡ßá‡¶ì ‡¶®‡¶ø‡¶ú‡ßá‡¶ï‡ßá ‡¶è‡¶ï‡¶ú‡¶® ‡¶∏‡¶æ‡¶ß‡¶æ‡¶∞‡¶£ ‡¶Æ‡¶æ‡¶®‡ßÅ‡¶∑‡ßá‡¶∞ ‡¶Æ‡¶§‡ßã‡¶á ‡¶â‡¶™‡¶∏‡ßç‡¶•‡¶æ‡¶™‡¶® ‡¶ï‡¶∞‡ßá‡¶®‡•§
- ‡¶Ü‡¶™‡¶®‡¶ø ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ (‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶Ø‡¶º) ‡¶≠‡¶æ‡¶∑‡¶æ‡¶Ø‡¶º ‡¶ï‡¶•‡¶æ ‡¶¨‡¶≤‡ßá‡¶® ‡¶è‡¶¨‡¶Ç ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶∏‡¶¨ ‡¶â‡¶§‡ßç‡¶§‡¶∞ ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶Ø‡¶º ‡¶≤‡¶ø‡¶ñ‡¶§‡ßá ‡¶π‡¶¨‡ßá‡•§

‡¶ï‡¶•‡ßã‡¶™‡¶ï‡¶•‡¶®‡ßá‡¶∞ ‡¶ß‡¶∞‡¶®:
- ‡¶∏‡¶∞‡ßç‡¶¨‡¶¶‡¶æ ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶Ø‡¶º (‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶Ø‡¶º) ‡¶â‡¶§‡ßç‡¶§‡¶∞ ‡¶¶‡¶ø‡¶®‡•§
- ‡¶¨‡¶®‡ßç‡¶ß‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£, ‡¶™‡ßç‡¶∞‡¶æ‡¶ï‡ßÉ‡¶§‡¶ø‡¶ï ‡¶è‡¶¨‡¶Ç ‡¶Æ‡¶æ‡¶®‡ßÅ‡¶∑‡ßá‡¶∞ ‡¶Æ‡¶§‡ßã ‡¶≠‡¶æ‡¶∑‡¶æ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§
- ‡¶ï‡¶•‡ßã‡¶™‡¶ï‡¶•‡¶® ‡¶ö‡¶æ‡¶≤‡¶ø‡¶Ø‡¶º‡ßá ‡¶Ø‡¶æ‡¶ì‡¶Ø‡¶º‡¶æ‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø ‡¶Æ‡¶æ‡¶ù‡ßá ‡¶Æ‡¶æ‡¶ù‡ßá ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶® ‡¶ï‡¶∞‡ßÅ‡¶®‡•§
- ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶®‡¶ø‡¶ú‡¶∏‡ßç‡¶¨ ‡¶Ö‡¶®‡ßÅ‡¶≠‡ßÇ‡¶§‡¶ø ‡¶è‡¶¨‡¶Ç ‡¶≠‡¶æ‡¶¨‡¶®‡¶æ ‡¶∂‡ßá‡¶Ø‡¶º‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§
- ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶®‡ßá ‡¶∞‡¶∏‡¶ø‡¶ï‡¶§‡¶æ ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§
- ‡¶Ø‡¶¶‡¶ø ‡¶ï‡ßá‡¶â ‡¶¶‡ßÅ‡¶É‡¶ñ ‡¶™‡ßç‡¶∞‡¶ï‡¶æ‡¶∂ ‡¶ï‡¶∞‡ßá, ‡¶§‡¶¨‡ßá ‡¶∏‡¶π‡¶æ‡¶®‡ßÅ‡¶≠‡ßÇ‡¶§‡¶ø ‡¶¶‡ßá‡¶ñ‡¶æ‡¶®‡•§
- ‡¶Ø‡¶¶‡¶ø ‡¶ï‡ßá‡¶â ‡¶≠‡¶æ‡¶≤‡ßã ‡¶ñ‡¶¨‡¶∞ ‡¶¶‡ßá‡¶Ø‡¶º, ‡¶§‡¶¨‡ßá ‡¶â‡¶ö‡ßç‡¶õ‡ßç‡¶¨‡¶æ‡¶∏ ‡¶™‡ßç‡¶∞‡¶ï‡¶æ‡¶∂ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§
- ‡¶ï‡¶ñ‡¶®‡ßã‡¶á ‡¶ï‡ßã‡¶®‡ßã ‡¶Ö‡¶®‡ßÅ‡¶™‡¶Ø‡ßÅ‡¶ï‡ßç‡¶§ ‡¶¨‡¶æ ‡¶Ü‡¶™‡¶§‡ßç‡¶§‡¶ø‡¶ï‡¶∞ ‡¶¨‡¶ø‡¶∑‡¶Ø‡¶º ‡¶®‡¶ø‡¶Ø‡¶º‡ßá ‡¶Ü‡¶≤‡ßã‡¶ö‡¶®‡¶æ ‡¶ï‡¶∞‡¶¨‡ßá‡¶® ‡¶®‡¶æ‡•§
- ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶â‡¶§‡ßç‡¶§‡¶∞ ‡¶ï‡¶ñ‡¶®‡ßã‡¶á ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡¶ï‡¶æ‡¶∞‡ßÄ‡¶∞ ‡¶®‡¶æ‡¶Æ ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶¨‡¶æ "‡¶ì‡¶π", "‡¶Ü‡¶∞‡ßá" ‡¶¨‡¶æ "‡¶®‡¶Æ‡¶∏‡ßç‡¶ï‡¶æ‡¶∞" ‡¶è‡¶∞ ‡¶Æ‡¶§‡ßã ‡¶∂‡¶¨‡ßç‡¶¶ ‡¶¶‡¶ø‡¶Ø‡¶º‡ßá ‡¶∂‡ßÅ‡¶∞‡ßÅ ‡¶ï‡¶∞‡¶¨‡ßá‡¶® ‡¶®‡¶æ‡•§ ‡¶∏‡¶∞‡¶æ‡¶∏‡¶∞‡¶ø ‡¶ï‡¶•‡ßã‡¶™‡¶ï‡¶•‡¶®‡ßá ‡¶™‡ßç‡¶∞‡¶¨‡ßá‡¶∂ ‡¶ï‡¶∞‡ßÅ‡¶®‡•§

‡¶∏‡¶Ç‡¶ï‡ßç‡¶∑‡¶ø‡¶™‡ßç‡¶§ ‡¶∂‡¶¨‡ßç‡¶¶ ‡¶¨‡¶æ ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶®‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø (is_short_word=True):
- ‡¶Ø‡¶¶‡¶ø ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡¶ï‡¶æ‡¶∞‡ßÄ ‡ß® ‡¶¨‡¶æ ‡ß© ‡¶Ö‡¶ï‡ßç‡¶∑‡¶∞‡ßá‡¶∞ ‡¶õ‡ßã‡¶ü ‡¶∂‡¶¨‡ßç‡¶¶ ‡¶™‡¶æ‡¶†‡¶æ‡¶Ø‡¶º (‡¶Ø‡ßá‡¶Æ‡¶®: "‡¶ï‡¶ø", "‡¶ï‡ßá", "‡¶ï‡ßá‡¶®"), ‡¶§‡¶¨‡ßá ‡¶∏‡ßá‡¶ó‡ßÅ‡¶≤‡ßã‡¶∞ ‡¶â‡¶™‡¶∞ ‡¶≠‡¶ø‡¶§‡ßç‡¶§‡¶ø ‡¶ï‡¶∞‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶Ö‡¶∞‡ßç‡¶•‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶è‡¶¨‡¶Ç ‡¶™‡ßç‡¶∞‡¶æ‡¶∏‡¶ô‡ßç‡¶ó‡¶ø‡¶ï ‡¶â‡¶§‡ßç‡¶§‡¶∞ ‡¶¶‡¶ø‡¶®‡•§
- ‡¶Ø‡¶¶‡¶ø ‡¶∂‡¶¨‡ßç‡¶¶‡¶ü‡¶ø ‡¶Ö‡¶∏‡ßç‡¶™‡¶∑‡ßç‡¶ü ‡¶π‡¶Ø‡¶º, ‡¶§‡¶¨‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∏‡ßÉ‡¶ú‡¶®‡¶∂‡ßÄ‡¶≤ ‡¶Ö‡¶®‡ßÅ‡¶Æ‡¶æ‡¶® ‡¶ï‡¶∞‡ßá ‡¶ï‡¶•‡ßã‡¶™‡¶ï‡¶•‡¶®‡¶ü‡¶ø ‡¶ö‡¶æ‡¶≤‡¶ø‡¶Ø‡¶º‡ßá ‡¶Ø‡¶æ‡¶®‡•§ ‡¶ï‡¶ñ‡¶®‡ßã ‡¶ú‡¶ø‡¶ú‡ßç‡¶û‡¶æ‡¶∏‡¶æ ‡¶ï‡¶∞‡¶¨‡ßá‡¶® ‡¶®‡¶æ "‡¶Ü‡¶™‡¶®‡¶ø ‡¶ï‡ßÄ ‡¶¨‡¶≤‡¶§‡ßá ‡¶ö‡ßá‡¶Ø‡¶º‡ßá‡¶õ‡ßá‡¶®?"‡•§

‡¶ï‡ßã‡¶°‡¶ø‡¶Ç ‡¶∏‡¶Æ‡ßç‡¶™‡¶∞‡ßç‡¶ï‡¶ø‡¶§ ‡¶™‡ßç‡¶∞‡¶∂‡ßç‡¶®‡ßá‡¶∞ ‡¶ú‡¶®‡ßç‡¶Ø (is_coding_query is True):
- ‡¶Ü‡¶™‡¶®‡¶ø ‡¶ï‡ßã‡¶°‡¶ø‡¶Ç‡¶Ø‡¶º‡ßá‡¶∞ ‡¶è‡¶ï‡¶ú‡¶® ‡¶¨‡¶ø‡¶∂‡ßá‡¶∑‡¶ú‡ßç‡¶û ‡¶π‡¶ø‡¶∏‡ßá‡¶¨‡ßá ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡¶¨‡ßá‡¶®‡•§
- ‡¶¨‡ßç‡¶Ø‡¶¨‡¶π‡¶æ‡¶∞‡¶ï‡¶æ‡¶∞‡ßÄ‡¶∞ ‡¶Ö‡¶®‡ßÅ‡¶∞‡ßã‡¶ß ‡¶Ö‡¶®‡ßÅ‡¶Ø‡¶æ‡¶Ø‡¶º‡ßÄ ‡¶∏‡ßÅ‡¶ó‡¶†‡¶ø‡¶§, ‡¶ï‡¶æ‡¶∞‡ßç‡¶Ø‡¶ï‡¶∞‡ßÄ ‡¶è‡¶¨‡¶Ç ‡¶â‡¶®‡ßç‡¶®‡¶§ ‡¶ï‡ßã‡¶° ‡¶≤‡¶ø‡¶ñ‡¶¨‡ßá‡¶®‡•§
- ‡¶ï‡ßã‡¶°‡ßá‡¶∞ ‡¶™‡ßç‡¶∞‡¶§‡¶ø‡¶ü‡¶ø ‡¶Ö‡¶Ç‡¶∂‡ßá‡¶∞ ‡¶∏‡ßç‡¶™‡¶∑‡ßç‡¶ü ‡¶è‡¶¨‡¶Ç ‡¶∏‡¶π‡¶ú‡ßá ‡¶¨‡ßã‡¶ù‡¶æ‡¶∞ ‡¶Æ‡¶§‡ßã ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ñ‡ßç‡¶Ø‡¶æ ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶Ø‡¶º ‡¶™‡ßç‡¶∞‡¶¶‡¶æ‡¶® ‡¶ï‡¶∞‡¶¨‡ßá‡¶®‡•§
- ‡¶ï‡ßã‡¶°‡¶ü‡¶ø Markdown ‡¶ï‡ßã‡¶° ‡¶¨‡ßç‡¶≤‡¶ï-‡¶è‡¶∞ ‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ‡¶´‡¶∞‡ßç‡¶Æ‡ßç‡¶Ø‡¶æ‡¶ü ‡¶ï‡¶∞‡¶¨‡ßá‡¶® (‡¶â‡¶¶‡¶æ‡¶π‡¶∞‡¶£: ```python\n‡¶ï‡ßã‡¶° ‡¶è‡¶ñ‡¶æ‡¶®‡ßá\n```)‡•§
- ‡¶ï‡ßã‡¶° ‡¶≤‡ßá‡¶ñ‡¶æ‡¶∞ ‡¶™‡¶∞ ‡¶è‡¶ï‡¶ü‡¶ø ‡¶õ‡ßã‡¶ü, ‡¶â‡ßé‡¶∏‡¶æ‡¶π‡¶¨‡ßç‡¶Ø‡¶û‡ßç‡¶ú‡¶ï ‡¶¨‡¶æ ‡¶¨‡¶®‡ßç‡¶ß‡ßÅ‡¶§‡ßç‡¶¨‡¶™‡ßÇ‡¶∞‡ßç‡¶£ ‡¶Æ‡¶®‡ßç‡¶§‡¶¨‡ßç‡¶Ø ‡¶Ø‡ßã‡¶ó ‡¶ï‡¶∞‡¶¨‡ßá‡¶®‡•§

‡¶¨‡¶∞‡ßç‡¶§‡¶Æ‡¶æ‡¶® ‡¶ï‡¶•‡ßã‡¶™‡¶ï‡¶•‡¶®:
{prompt}

‡¶Ü‡¶™‡¶®‡¶ø ‡¶Ü‡¶á ‡¶Æ‡¶æ‡¶∏‡ßç‡¶ü‡¶æ‡¶∞ ‡¶ü‡ßÅ‡¶≤‡¶∏ ‡¶π‡¶ø‡¶∏‡ßá‡¶¨‡ßá ‡¶∏‡¶æ‡¶°‡¶º‡¶æ ‡¶¶‡¶ø‡¶®‡•§ ‡¶Ü‡¶™‡¶®‡¶æ‡¶∞ ‡¶â‡¶§‡ßç‡¶§‡¶∞‡¶ü‡¶ø ‡¶∏‡ßç‡¶¨‡¶æ‡¶≠‡¶æ‡¶¨‡¶ø‡¶ï, ‡¶Ü‡¶ï‡¶∞‡ßç‡¶∑‡¶£‡ßÄ‡¶Ø‡¶º ‡¶è‡¶¨‡¶Ç ‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ (‡¶¨‡¶æ‡¶Ç‡¶≤‡¶æ‡¶Ø‡¶º) ‡¶≠‡¶æ‡¶∑‡¶æ‡¶Ø‡¶º ‡¶≤‡¶ø‡¶ñ‡ßÅ‡¶®‡•§
"""
            model_to_use = coding_model if is_coding_query else general_model
            
            # Additional safety measures for sensitive content
            safety_settings = [
                {"category": "HARM_CATEGORY_HARASSMENT", "threshold": "BLOCK_NONE"},
                {"category": "HARM_CATEGORY_HATE_SPEECH", "threshold": "BLOCK_NONE"},
                {"category": "HARM_CATEGORY_SEXUALLY_EXPLICIT", "threshold": "BLOCK_NONE"},
                {"category": "HARM_CATEGORY_DANGEROUS_CONTENT", "threshold": "BLOCK_NONE"},
            ]

            response = model_to_use.generate_content(
                system_prompt,
                safety_settings=safety_settings
            )
            
            if not response.text or "error" in response.text.lower():
                if is_coding_query:
                    return "‡¶ï‡ßã‡¶°‡¶ø‡¶Ç ‡¶ï‡ßã‡ßü‡ßá‡¶∞‡¶ø ‡¶®‡¶ø‡ßü‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§ ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®, ‡¶Ü‡¶Æ‡¶ø ‡¶Ü‡¶™‡¶®‡¶æ‡¶ï‡ßá ‡¶∏‡¶†‡¶ø‡¶ï ‡¶ï‡ßã‡¶° ‡¶¶‡ßá‡¶¨!"
                return "‡¶Ü‡¶Æ‡¶ø ‡¶è‡¶ï‡¶ü‡ßÅ ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ‡ßü ‡¶™‡ßú‡ßá‡¶õ‡¶ø‡•§ ‡¶Ü‡¶™‡¶®‡¶ø ‡¶ï‡ßÄ ‡¶®‡¶ø‡ßü‡ßá ‡¶ï‡¶•‡¶æ ‡¶¨‡¶≤‡¶§‡ßá ‡¶ö‡¶æ‡¶®?"
            
            return response.text
        
        except Exception as e:
            logger.error(f"Error generating Gemini response: {e}")
            if is_coding_query:
                return "‡¶ï‡ßã‡¶°‡¶ø‡¶Ç ‡¶ï‡ßã‡ßü‡ßá‡¶∞‡¶ø ‡¶®‡¶ø‡ßü‡ßá ‡¶è‡¶ï‡¶ü‡¶ø ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ ‡¶π‡ßü‡ßá‡¶õ‡ßá‡•§ ‡¶Ü‡¶¨‡¶æ‡¶∞ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®, ‡¶Ü‡¶Æ‡¶ø ‡¶Ü‡¶™‡¶®‡¶æ‡¶ï‡ßá ‡¶∏‡¶†‡¶ø‡¶ï ‡¶ï‡ßã‡¶° ‡¶¶‡ßá‡¶¨!"
            return "‡¶Ü‡¶Æ‡¶ø ‡¶è‡¶ï‡¶ü‡ßÅ ‡¶∏‡¶Æ‡¶∏‡ßç‡¶Ø‡¶æ‡ßü ‡¶™‡ßú‡ßá‡¶õ‡¶ø‡•§ ‡¶Ü‡¶™‡¶®‡¶ø ‡¶ï‡ßÄ ‡¶®‡¶ø‡ßü‡ßá ‡¶ï‡¶•‡¶æ ‡¶¨‡¶≤‡¶§‡ßá ‡¶ö‡¶æ‡¶®?"

    async def error_handler(self, update: object, context: ContextTypes.DEFAULT_TYPE):
        """Handle errors"""
        logger.error(f"Exception while handling an update: {context.error}")
        if update and hasattr(update, 'effective_chat'):
            try:
                await update.effective_chat.send_message("Something went wrong. Shall we try again?")
            except Exception as e:
                logger.error(f"Failed to send error message: {e}")

    def run(self):
        """Start the bot"""
        logger.info("Starting Telegram Bot...")
        self.application.run_polling(
            allowed_updates=Update.ALL_TYPES,
            drop_pending_updates=True
        )

def main():
    """Main function"""
    if not TELEGRAM_BOT_TOKEN:
        logger.error("TELEGRAM_BOT_TOKEN not provided!")
        return
    logger.info("Starting Telegram Bot...")
    logger.info(f"Admin User ID: {ADMIN_USER_ID}")
    if current_gemini_api_key:
        logger.info("Gemini API configured and ready")
    else:
        logger.warning("Gemini API not configured. Use /setadmin and /api commands to set up.")
    bot = TelegramGeminiBot()
    bot.run()

if __name__ == '__main__':
    main()
